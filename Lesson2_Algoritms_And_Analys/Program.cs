Console.Clear();
Console.WriteLine("Bootkemp_Lesson02_Algoritms_And_Analys");
Console.WriteLine("");

/* 
О = сложность алгоритма; () - количество действий 
1. Константные = О(1) или  О(2) или ...
2. Логарифмические - Бинарный поиск
3. Линейные = О (n) или О(2 * N)
4. Линейно-логарифмические - быстрая сортировка
5. Квадратные - пузырьковая сортировка, сортировка ортировка выбором, сортировка вставками и др
6. Кубические - трехмерные массивы 
*/

// Напишите программу, которая считает сумму чисел от 1 до n. (1 и 3 тип алгоритма)

// //============================== FUNCTIONS ===============================
int ConsolePrintRead(int number = 0)
{
    Console.WriteLine("Print the N number and press Enter");
    //number = Convert.ToInt32(Console.ReadLine()); - работает, но медленнее чем int.Parse
    number = int.Parse(Console.ReadLine()!); // ! - чтобы убрать предупреждение о том что нельзя вводить пустую строку
    return number;
}

int Sum1toN(int n)
{
    int sum = 0;
    for (int i = 1; i <= n; i++)
    {
        sum = sum + i;
    }
    return sum;
    // альтернатива, но работает некорректно с int ибо в формуле есть деление
    // sum = (1 + n)/2.0 * n; 
    // return sum;

}
// //================================ Main ==================================
int n = ConsolePrintRead();
Console.Clear();
Console.WriteLine("N = " + n);
Console.WriteLine("Sum of the elements from 1 to " + n + " = " + Sum1toN(n));


// Бинарный поиск (двойной поиск) - 2Й тип алгоритма
// загаданное число 67
// от 1 до 100
// число больше 100/2? - да, от 50 до 100
//число больше (100 + 50)/2? - нет, от 50 до 75
// число больше (50 + 75)/2? - да, от 62 до 75
// число больше (62 + 75)/2? - нет, от 62 до 68
// число больше (62 + 68)/2? - да, от 65 до 68 
// число больше (65 + 68)/2? - да, от 66 до 68
// число больше чем (66+68)/2? - нет, =>ответ 67
// Сложность алгоритма бинарного поиска равен 0(log2(n))


// Быстрая сортировка О(n * log2(n)) (рекурсивный подход)

// [34, -10, 23, 5, 2, 1]
//1. Выбирается опорный элемент (в основном берется первый элемент массива)
//2. Создается 2 массива. 1Й массив содержит элементы опорного, 2й массив содержит элементы больше или равные опорному

// Опорный элемент равен 34       [-10, 1, 2, 5, 23, 34]
// [-10, 23, 5, 2, 1] + [34] + []
// Опорный элемент равен -10     [-10, 1, 2, 5, 23]
// [] + [-10] + [23, 5, 2, 1]
// Опорный элемент равен 23     [1, 2, 5, 23]
// [5, 2, 1] + [23] + []
// Опорный элемент равен 5     [1, 2, 5]
// [2, 1] + [5] + []
// Опорный элемент равен 2
// [1] + [2] + []
// 




